---
layout: single
title:  "강의 2화~4화 : 자료형"
---

# //

 - 주석
 - 설명 역할, 코드로 인식되지 않는다

```c++
// 주석
// 설명 역할, 코드로 인식되지 않는다
```



# 자료형 (Data Type)

## 정수형  (크기단위 : Byte)

​	: char(1), short(2), int(4), long(4), long long(8) ...

## 실수형 

​	: float(4), double(8)

## 크기 단위

```c++
// 1Byte = 8 bit 
// bit 는 더이상 쪼갤 수 없는 단위 (0 또는 1)

// 1024 Byte -> 1KB
// 1024 KB   -> 1MB
// 1024 MB   -> GB
// 1024 GB   -> TB
```

## unsigned

```c++
int i = 0;
unsigned char c = 0;

// unsigned char : 1바이트 정수인데, "양"의 정수만 표현
// c는 1바이트 = 8비트 이므로 256가지의 양의 정수 표현 가능
// 따라서 0~255
```

## 비트 한계를 넘는 경우

```C++
c = 0; 
c = 255;

// = 하나는 "대입"연산자
// == (두개)는 "일치", 즉 양쪽이 동일한지 여부

c = 256;  

// 255까지만 가능하므로, 안들어감
// 256은 9바이트 숫자 (1000000...) 
// 그 전 대입값인 255가 유지됨.
```



# 전체 코드




```c++


int main()
{

	// 자료형, Data Type (크기 단위 : byte)
	// 정수형 : char(1), short(2), int(4), long(4), long long(8) ...
	 
	// 실수형 : float(4), double(8)



	// 1Byte = 8 bit 
	// bit 는 더이상 쪼갤 수 없는 단위 (0 또는 1)

	// 1024 Byte -> 1KB
	// 1024 KB   -> 1MB
	// 1024 MB   -> GB
	// 1024 GB   -> TB

	int i = 0;
	unsigned char c = 0;

	// unsigned char : 1바이트 정수인데, "양"의 정수만 표현
	// c는 1바이트 = 8비트 이므로 256가지의 양의 정수 표현 가능
	// 따라서 0~255

	c = 0; 
	c = 255;

	// = 하나는 "대입"연산자
	// == (두개)는 "일치", 즉 양쪽이 동일한지 여부

	c = 256;  

	// 255까지만 가능하므로, 안들어감
	// 256은 9바이트 숫자 (1000000...) 
	// 그 전 대입값인 255가 유지됨.


	c = -1; 



	c;




	




	return 0;
}
```


# 전체코드



```c++
int main()
{

	// 자료형, Data Type (크기 단위 : byte)
	// 정수형 : char(1), short(2), int(4), long(4), long long(8) ...
	 
	// 실수형 : float(4), double(8)



	// 1Byte = 8 bit 
	// bit 는 더이상 쪼갤 수 없는 단위 (0 또는 1)
	
	// 1024 Byte -> 1KB
	// 1024 KB   -> 1MB
	// 1024 MB   -> GB
	// 1024 GB   -> TB
	
	int i = 0;
	unsigned char c = 0;
	
	// unsigned char : 1바이트 정수인데, "양"의 정수만 표현
	// c는 1바이트 = 8비트 이므로 256가지의 양의 정수 표현 가능
	// 따라서 0~255
	
	c = 0; 
	c = 255;
	
	// = 하나는 "대입"연산자
	// == (두개)는 "일치", 즉 양쪽이 동일한지 여부
	
	c = 256;  
	
	// 255까지만 가능하므로, 안들어감
	// 256은 9바이트 숫자 (1000000...) 
	// 그 전 대입값인 255가 유지됨.


	char c1 = 0;
	
	// 사실 char 앞에는 signed 가 생략됨 (디폴트)
	// signed : 양수/음수 모두 표현
	
	// 1 바이트로 양수만 표현 :      256가지 -> 0 ~ 255
	// 1 바이트로 양/음수 둘다 표현 : 256가지 -> -128 ~ 0 ~ 127
	/*
	이게 어떤 의미이나면,
		8바이트이므로 2^8 = 256인데
		맨앞이 0일때의 나머지 7자리를 정하는 경우의 수 2^7과
		맨앞이 1일떄의 나머지 7자리를 정하는 경우의 수 2^7을
		더하면 2 * 2^7 = 256이 되는 구조임
	
		맨앞이 0인 경우를 양수로 (0~127),
			   1인 경우를 음수로 함 (-1 ~ -128)


        그리고 이 맨 앞 비트 (부호비트)를 
    		MSB (Most Significant Bit)라고 함


​		

		ex) 00000001  = 1
		    10000001  = -1 ?  NO
	
			비트의 뺄셈 -> 덧셈으로 치환
			
			127 - 127 = 0
			127 + (-127) = 0
	
			따라서 음수 (-127)을 찾기 위해서는 
	
			양수 (127) 와 더해서 0이 되는 숫자를 찾아야 함
	
			(부호비트는 1이면서)
	
			ex) 
	
			127 = 0	1 1 1  1 1 1 1
	
				+ 1 0 0 0  0 0 0 1	
			-----------------------
				1 0 0 0 0  0 0 0 0
	
				여기서 맨앞 1은 8비트 초과하므로 배정이 안됨
				따라서 합해서 0이 되는 숫자를 찾음
	
				따라서 10000001 = -127


			ex) 
			1 = 0 0 0 0  0 0 0 1
			 +  1 1 1 1  1 1 1 1
			-----------------------
			  1 0 0 0 0  0 0 0 0
	
			  따라서 11111111 = -1 


	*/
	
	c1 = 255;
	
	/* c1 (양/음수 모두 표현)에 255 입력하면,
	   이건 unsigned 기준에서는 11111111로 255이지만
	   signed 기준에서는 11111111 = -1이므로
	   결과적으로 -1로 처리가 됨
	   
	   데이터는 11111111로 똑같지만
	   어떻게 해석하느냐에 따라 (signed/unsigned)
	   어떤 관점인지에 따라
	   그 의미가 달라진다.
	   
	   이것은 이후의 포인터에서도 나오는 개념이다.


​	   

	   */
	
	c = -1;
	
	/* c (양수만 표현)에  입력하면,
	   이건 signed 기준에서는 11111111로 -1 이지만
	   unsigned 기준에서는 11111111 = 255 이므로
	   결과적으로 255 로 처리가 됨
	
	   데이터는 11111111로 똑같지만
	   어떻게 해석하느냐에 따라 (signed/unsigned)
	   어떤 관점인지에 따라
	   그 의미가 달라진다.
	
	   이것은 이후의 포인터에서도 나오는 개념이다.
	
	   */


	/* 2의 보수법 : 음의 정수를 찾는 방법 
		각 자리에 대해 0이면 1, 1이면 0으로 쓰고
		트리거로 1만 더해줘서 음수를 찾는 것
		
		ex) 
			2 = 0000 0010 의 음수값 찾기
			
			->  1111 1101     : 보수만 찾으면 더했을때 1111 1111이 됨
			->  1111 1101
			 +  0000 0001    =1 
			-------------------
			    1111 1110   = -2 
		*/



	/* 1바이트(char) = 8 비트 = 2^8 = 256가지
	   2바이트(short) = 16비트 = 2^16 = 65536 가지 
	
	   (1바이트 증가로 인해 표현할 수 있는 경우의 수는
		기하급수적으로 늘어난다)


​	
​	

	*/



	return 0;

}
```












